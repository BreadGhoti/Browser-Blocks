<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Browser Blocks</title>
		<style>
body {
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    background-color: #f0f0f0;
}

button {
    font-size: 18px;
    padding: 10px 20px;
    margin: 10px;
    cursor: pointer;
}

#settingsBtn {
    position: fixed;
    top: 20px;
    right: 20px;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 5px;
}

.settings-panel {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 30px;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0,0,0,0.2);
    z-index: 1000;
    width: 80%;
    max-width: 800px;
}

.settings-panel.show {
    display: block;
}

.settings-content {
    display: grid;
    grid-template-columns: 1fr;
    gap: 20px;
    margin-top: 20px;
}

@media (min-width: 768px) {
    .settings-content {
        grid-template-columns: 1fr 1fr;
    }
}

.setting-item {
    display: flex;
    align-items: center;
    gap: 10px;
}

.setting-item label {
    min-width: 150px;
    font-size: 14px;
    color: #666;
}

.setting-item input {
    width: 120px;
    padding: 8px 12px;
    border: 2px solid #e0e0e0;
    border-radius: 6px;
    font-size: 14px;
    transition: border-color 0.2s;
}

.setting-item input:focus {
    outline: none;
    border-color: #4CAF50;
    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.1);
}

.setting-item input:hover {
    border-color: #bdbdbd;
}

@media (max-width: 767px) {
    .setting-item {
        flex-direction: column;
        align-items: flex-start;
    }

    .setting-item input {
        width: 100%;
    }
}

.close-btn {
    position: absolute;
    top: 15px;
    right: 15px;
    cursor: pointer;
    font-size: 24px;
    color: #666;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: background-color 0.2s;
}

.close-btn:hover {
    background-color: #f5f5f5;
}

h2 {
    margin: 0;
    color: #333;
    font-size: 20px;
}

.settings-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

#resetSettings {
    background: #ff5722;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 8px 16px;
    font-size: 14px;
    cursor: pointer;
    transition: background-color 0.2s;
}

#resetSettings:hover {
    background: #f4511e;
}
		</style>
	</head>
	<h1>Browser Blocks</h1>
    <button id="settingsBtn">&#9881;</button>
	<body>
		<button id="createWindow">Spawn Block</button>
		<button id="createTrampoline">Spawn Trampoline</button>
		<button id="createConveyorBelt">Spawn Conveyor Belt</button>
		<button id="createPortals">Spawn Portals</button>
		<button id="createFan">Spawn Fan</button>
		<button id="createWater">Create Water</button>
		<button id="createEraser">Spawn Eraser</button>
		<p><small>Made by <a style="white-space:nowrap" href="https://github.com/BreadGhoti">BreadGhoti</a></small></p>
        <div class="settings-panel" id="settingsPanel">
    <span class="close-btn" id="closeSettings">Ã—</span>
    <div class="settings-header">
        <h2>Settings</h2>
        <button id="resetSettings">Reset to Default</button>
    </div>
    <div class="settings-content">
        <div class="settings-column">
            <div class="setting-item">
                <label for="gravity">Gravity:</label>
                <input type="number" id="gravity" step="0.1" />
            </div>
            <div class="setting-item">
                <label for="friction">Friction:</label>
                <input type="number" id="friction" step="0.1" />
            </div>
            <div class="setting-item">
                <label for="windowFriction">Window Friction:</label>
                <input type="number" id="windowFriction" step="0.01" />
            </div>
            <div class="setting-item">
                <label for="trampolineBounceFactor">Trampoline Bounce:</label>
                <input type="number" id="trampolineBounceFactor" step="0.1" />
            </div>
            <div class="setting-item">
                <label for="conveyorSpeed">Conveyor Speed:</label>
                <input type="number" id="conveyorSpeed" step="0.5" />
            </div>
            <div class="setting-item">
                <label for="portalCooldown">Portal Cooldown (ms):</label>
                <input type="number" id="portalCooldown" step="100" />
            </div>
        </div>
        <div class="settings-column">
            <div class="setting-item">
                <label for="fanForce">Fan Force:</label>
                <input type="number" id="fanForce" step="0.1" />
            </div>
            <div class="setting-item">
                <label for="fanRange">Fan Range:</label>
                <input type="number" id="fanRange" step="10" />
            </div>
            <div class="setting-item">
                <label for="fanLiftForce">Fan Lift Force:</label>
                <input type="number" id="fanLiftForce" step="0.1" />
            </div>
            <div class="setting-item">
                <label for="fanHoverDistance">Fan Hover Distance:</label>
                <input type="number" id="fanHoverDistance" step="10" />
            </div>
            <div class="setting-item">
                <label for="buoyancyForce">Buoyancy Force:</label>
                <input type="number" id="buoyancyForce" step="0.1" />
            </div>
            <div class="setting-item">
                <label for="waterDrag">Water Drag:</label>
                <input type="number" id="waterDrag" step="0.01" />
            </div>
        </div>
    </div>
</div>
		<script>
        const defaultSettings = {
    gravity: 0.5,
    friction: 0.3,
    windowFriction: 0.95,
    trampolineBounceFactor: 0.9,
    conveyorSpeed: 2,
    portalCooldown: 2000,
    fanForce: 1,
    fanRange: 300,
    fanLiftForce: 0.6,
    fanHoverDistance: 200,
    buoyancyForce: 0.3,
    waterDrag: 0.95
};
			let gravity = 0.5;
let friction = 0.3;
let windowFriction = 0.95;
let trampolineBounceFactor = 0.9;
let conveyorSpeed = 2;
let portalCooldown = 2000;
let fanForce = 1;
let fanRange = 300;
let fanLiftForce = 0.6;
let fanHoverDistance = 200;
let buoyancyForce = 0.3;
let waterDrag = 0.95;
			const windows = [];
			let portals = [];
			
			function createWindow(isTrampoline = false, isConveyorBelt = false, isPortal = false, isFan = false, isEraser = false, isWater = false) {
			    const width = Math.floor(Math.random() * 100) + 150;
			    const height = Math.floor(Math.random() * 100) + 100;
			    let color;
			    if (isTrampoline) {
			        color = '#000000';
			    } else if (isConveyorBelt) {
			        color = '#808080';
			    } else if (isPortal) {
			        color = '#FF00FF'; // Magenta color for portals
			    } else if (isFan) {
			        color = '#00FFFF'; // Cyan color for fans
			    } else if (isEraser) {
			        color = '#FF0000'; // Red color for eraser
			    } else if (isWater) {
			        color = 'rgba(0, 0, 255, 0.5)'; // Semi-transparent blue for water
			    } else {
			        color = `hsl(${Math.random() * 360}, 70%, 50%)`;
			    }
			    const newWindow = window.open('', '', `width=${width},height=${height},resizable=yes`);
			    
			    newWindow.document.write(`
			        <html>
			        <head>
			            <title>${isTrampoline ? 'Trampoline' : isConveyorBelt ? 'Conveyor Belt' : isPortal ? 'Portal' : isFan ? 'Fan' : isEraser ? 'Eraser' : isWater ? 'Water' : 'Normal'} Block</title>
			            <style>
			                body {
			                    background-color: ${color};
			                    display: flex;
			                    flex-direction: column;
			                    justify-content: ${isWater ? 'flex-start' : 'center'};
			                    align-items: center;
			                    height: 100vh;
			                    margin: 0;
			                    font-family: Arial, sans-serif;
			                    color: ${isTrampoline || isConveyorBelt || isPortal || isFan || isEraser ? 'white' : 'black'};
			                    font-size: 18px;
			                    user-select: none;
			                    cursor: grab;
			                    overflow: hidden;
			                }
			                body:active {
			                    cursor: grabbing;
			                }
			                button {
			                    font-size: 14px;
			                    padding: 5px 10px;
			                }
			                #cooldown {
			                    font-size: 24px;
			                    font-weight: bold;
			                }
			                ${isWater ? `
			                .water-surface {
			                    width: 100%;
			                    height: 10px;
			                    background: linear-gradient(to bottom, rgba(255,255,255,0.3), transparent);
			                    position: absolute;
			                    top: 0;
			                    left: 0;
			                }
			                ` : ''}
			            </style>
			        </head>
			        <body>
			            ${isWater ? '<div class="water-surface"></div>' : ''}
			            ${isConveyorBelt || isFan ? '<button id="changeDirection">&#8635;</button>' : 
			              isPortal ? '<div id="cooldown">Ready</div>' :
			              isEraser ? '<div>Eraser</div>' :
			              isWater ? '<div>Water</div>' :
			              `<div>${isTrampoline ? 'Boing!' : isFan ? 'Whoosh!' : 'Block'}</div>`}
			        </body>
			        </html>
			    `);
			
			    const windowData = {
			        window: newWindow,
			        width: width,
			        height: height,
			        x: Math.round(Math.random() * (window.screen.availWidth - width)),
			        y: Math.round(Math.random() * (window.screen.availHeight - height)),
			        vx: 0,
			        vy: 0,
			        isDragging: false,
			        lastX: 0,
			        lastY: 0,
			        offsetX: 0,
			        offsetY: 0,
			        mass: width * height / 10000,
			        lastFocusTime: Date.now(),
			        isTrampoline: isTrampoline,
			        isConveyorBelt: isConveyorBelt,
			        isPortal: isPortal,
			        isFan: isFan,
			        isEraser: isEraser,
			        isWater: isWater,
			        conveyorDirection: 'right',
			        fanDirection: 'right',
			        lastTeleportTime: 0,
			        isFlying: false
			    };
			
			    newWindow.moveTo(windowData.x, windowData.y);
			    newWindow.focus();
			
			    newWindow.document.body.addEventListener('mousedown', (e) => {
			        windowData.isDragging = true;
			        windowData.offsetX = e.screenX - windowData.x;
			        windowData.offsetY = e.screenY - windowData.y;
			        windowData.lastX = e.screenX;
			        windowData.lastY = e.screenY;
			        windowData.vx = 0;
			        windowData.vy = 0;
			        windowData.lastFocusTime = Date.now();
			    });
			
			    newWindow.document.addEventListener('mousemove', (e) => {
			        if (windowData.isDragging) {
			            windowData.x = e.screenX - windowData.offsetX;
			            windowData.y = e.screenY - windowData.offsetY;
			            newWindow.moveTo(windowData.x, windowData.y);
			
			            windowData.vx = e.screenX - windowData.lastX;
			            windowData.vy = e.screenY - windowData.lastY;
			            windowData.lastX = e.screenX;
			            windowData.lastY = e.screenY;
			        }
			    });
			
			    newWindow.document.addEventListener('mouseup', () => {
			        windowData.isDragging = false;
			        windowData.vx *= 5;
			        windowData.vy *= 5;
			    });
			
			    newWindow.addEventListener('blur', () => {
			        windowData.isDragging = false;
			    });
			
			    newWindow.addEventListener('resize', () => {
			        updateWindowSize(windowData);
			    });
			
			    if (isConveyorBelt || isFan) {
			        newWindow.document.getElementById('changeDirection').addEventListener('click', () => {
			            const directions = ['right', 'down', 'left', 'up'];
			            const currentIndex = directions.indexOf(windowData.isConveyorBelt ? windowData.conveyorDirection : windowData.fanDirection);
			            if (windowData.isConveyorBelt) {
			                windowData.conveyorDirection = directions[(currentIndex + 1) % directions.length];
			            } else {
			                windowData.fanDirection = directions[(currentIndex + 1) % directions.length];
			            }
			        });
			    }
			
			    windows.push(windowData);
			    return windowData;
			}
			
			function createPortals() {
			    if (portals.length === 2) {
			        portals.forEach(portal => portal.window.close());
			        portals = [];
			    }
			    
			    const portal1 = createWindow(false, false, true);
			    const portal2 = createWindow(false, false, true);
			    
			    portals = [portal1, portal2];
			}
			
			function updateWindowSize(windowData) {
			    const newWidth = windowData.window.outerWidth;
			    const newHeight = windowData.window.outerHeight;
			    const dx = newWidth - windowData.width;
			    const dy = newHeight - windowData.height;
			
			    windowData.x -= dx / 2;
			    windowData.y -= dy / 2;
			
			    windowData.width = newWidth;
			    windowData.height = newHeight;
			    windowData.mass = windowData.width * windowData.height / 10000;
			
			    windowData.x = Math.max(0, Math.min(windowData.x, window.screen.availWidth - windowData.width));
			    windowData.y = Math.max(0, Math.min(windowData.y, window.screen.availHeight - windowData.height));
			
			    windowData.window.moveTo(Math.round(windowData.x), Math.round(windowData.y));
			}
			
			function checkCollision(a, b) {
			    return a.x < b.x + b.width &&
			           a.x + a.width > b.x &&
			           a.y < b.y + b.height &&
			           a.y + a.height > b.y;
			}
			
			function resolveCollision(a, b) {
			    if (a.isEraser || b.isEraser) {
			        const eraserWindow = a.isEraser ? a : b;
			        const targetWindow = a.isEraser ? b : a;
			        
			        if (!targetWindow.isEraser) {
			            targetWindow.window.close();
			            const index = windows.indexOf(targetWindow);
			            if (index > -1) {
			                windows.splice(index, 1);
			            }
			            return;
			        }
			    }
			
			    if (a.isPortal || b.isPortal) {
			        const portalWindow = a.isPortal ? a : b;
			        const teleportingWindow = a.isPortal ? b : a;
			        
			        if (!teleportingWindow.isPortal) {
			            const otherPortal = portals.find(portal => portal !== portalWindow);
			            if (otherPortal && Date.now() - teleportingWindow.lastTeleportTime > portalCooldown) {
			                teleportingWindow.x = otherPortal.x + (otherPortal.width - teleportingWindow.width) / 2;
			                teleportingWindow.y = otherPortal.y + (otherPortal.height - teleportingWindow.height) / 2;
			                teleportingWindow.window.moveTo(Math.round(teleportingWindow.x), Math.round(teleportingWindow.y));
			                teleportingWindow.lastTeleportTime = Date.now();
			            }
			        }
			        return;
			    }
			
			    if (a.isTrampoline || b.isTrampoline) {
			        const trampolineWindow = a.isTrampoline ? a : b;
			        const bouncingWindow = a.isTrampoline ? b : a;
			
			        if (bouncingWindow.y + bouncingWindow.height > trampolineWindow.y &&
			            bouncingWindow.y < trampolineWindow.y) {
			            bouncingWindow.vy = -Math.abs(bouncingWindow.vy) * trampolineBounceFactor;
			            bouncingWindow.y = trampolineWindow.y - bouncingWindow.height;
			        }
			    } else if (a.isWater || b.isWater) {
			        // Do nothing for water collisions, as objects should pass through
			    } else {
			        const overlapX = Math.min(a.x + a.width, b.x + b.width) - Math.max(a.x, b.x);
			        const overlapY = Math.min(a.y + a.height, b.y + b.height) - Math.max(a.y, b.y);
			
			        if (overlapX < overlapY) {
			            const tempVx = a.vx;
			            a.vx = b.vx;
			            b.vx = tempVx;
			            if (a.x < b.x) {
			                a.x = b.x - a.width;
			            } else {
			                a.x = b.x + b.width;
			            }
			        } else {
			            const tempVy = a.vy;
			            a.vy = b.vy;
			            b.vy = tempVy;
			            if (a.y < b.y) {
			                a.y = b.y - a.height;
			            } else {
			                a.y = b.y + b.height;
			            }
			        }
			
			        const restitution = 0.8;
			        a.vx *= restitution * windowFriction;
			        a.vy *= restitution * windowFriction;
			        b.vx *= restitution * windowFriction;
			        b.vy *= restitution * windowFriction;
			
			        // Apply conveyor belt effect after collision
			        if (a.isConveyorBelt || b.isConveyorBelt) {
			            const conveyorWindow = a.isConveyorBelt ? a : b;
			            const movingWindow = a.isConveyorBelt ? b : a;
			
			            switch (conveyorWindow.conveyorDirection) {
			                case 'right':
			                    movingWindow.vx += conveyorSpeed;
			                    break;
			                case 'left':
			                    movingWindow.vx -= conveyorSpeed;
			                    break;
			                case 'down':
			                    movingWindow.vy += conveyorSpeed;
			                    break;
			                case 'up':
			                    movingWindow.vy -= conveyorSpeed;
			                    break;
			            }
			        }
			    }
			}
			
			function updatePortalCooldown() {
			portals.forEach(portal => {
			const cooldownElement = portal.window.document.getElementById('cooldown');
			if (cooldownElement) {
			    const timeLeft = Math.max(0, Math.ceil((portalCooldown - (Date.now() - portal.lastTeleportTime)) / 1000));
			    cooldownElement.textContent = timeLeft > 0 ? `Cooldown: ${timeLeft}s` : 'Ready';
			}
			});
			}
			
			function isInFanRange(fanWindow, otherWindow) {
			    const fanCenterX = fanWindow.x + fanWindow.width / 2;
			    const fanCenterY = fanWindow.y + fanWindow.height / 2;
			    const otherCenterX = otherWindow.x + otherWindow.width / 2;
			    const otherCenterY = otherWindow.y + otherWindow.height / 2;
			
			    switch (fanWindow.fanDirection) {
			        case 'right':
			            return otherWindow.x > fanWindow.x + fanWindow.width &&
			                   otherWindow.x < fanWindow.x + fanWindow.width + fanRange &&
			                   Math.abs(otherCenterY - fanCenterY) < fanWindow.height / 2;
			        case 'left':
			            return otherWindow.x + otherWindow.width < fanWindow.x &&
			                   otherWindow.x + otherWindow.width > fanWindow.x - fanRange &&
			                   Math.abs(otherCenterY - fanCenterY) < fanWindow.height / 2;
			        case 'down':
			            return otherWindow.y > fanWindow.y + fanWindow.height &&
			                   otherWindow.y < fanWindow.y + fanWindow.height + fanRange &&
			                   Math.abs(otherCenterX - fanCenterX) < fanWindow.width / 2;
			        case 'up':
			            return otherWindow.y + otherWindow.height < fanWindow.y &&
			                   otherWindow.y + otherWindow.height > fanWindow.y - fanRange &&
			                   Math.abs(otherCenterX - fanCenterX) < fanWindow.width / 2;
			    }
			    return false;
			}
			
			function applyFanForce(fanWindow, otherWindow) {
			    if (isInFanRange(fanWindow, otherWindow)) {
			        switch (fanWindow.fanDirection) {
			            case 'right':
			                otherWindow.vx += fanForce;
			                break;
			            case 'left':
			                otherWindow.vx -= fanForce;
			                break;
			            case 'down':
			                otherWindow.vy += fanForce;
			                break;
			            case 'up':
			                otherWindow.vy -= fanForce;
			                break;
			        }
			    }
			}
			
			function isInWater(windowData) {
			    for (let water of windows.filter(w => w.isWater)) {
			        if (checkCollision(windowData, water)) {
			            return true;
			        }
			    }
			    return false;
			}
			
			function applyWaterPhysics(windowData) {
			    if (isInWater(windowData) && !windowData.isWater) {
			        // Apply buoyancy force
			        windowData.vy -= buoyancyForce;
			        
			        // Apply water drag
			        windowData.vx *= waterDrag;
			        windowData.vy *= waterDrag;
			        
			        // Make blocks float to the top of the water
			        for (let water of windows.filter(w => w.isWater)) {
			            if (checkCollision(windowData, water)) {
			                // If the block is mostly submerged, push it up
			                if (windowData.y + windowData.height / 2 > water.y) {
			                    windowData.y = Math.max(windowData.y - 1, water.y - windowData.height + 5);
			                    windowData.vy = Math.min(windowData.vy, 0); // Prevent sinking
			                }
			                break;
			            }
			        }
			    }
			}
            
            // Settings panel functionality
const settingsBtn = document.getElementById('settingsBtn');
const settingsPanel = document.getElementById('settingsPanel');
const closeSettings = document.getElementById('closeSettings');

// Initialize settings inputs
document.getElementById('gravity').value = gravity;
document.getElementById('friction').value = friction;
document.getElementById('windowFriction').value = windowFriction;
document.getElementById('trampolineBounceFactor').value = trampolineBounceFactor;
document.getElementById('conveyorSpeed').value = conveyorSpeed;
document.getElementById('portalCooldown').value = portalCooldown;
document.getElementById('fanForce').value = fanForce;
document.getElementById('fanRange').value = fanRange;
document.getElementById('fanLiftForce').value = fanLiftForce;
document.getElementById('fanHoverDistance').value = fanHoverDistance;
document.getElementById('buoyancyForce').value = buoyancyForce;
document.getElementById('waterDrag').value = waterDrag;

// Settings event listeners
settingsBtn.addEventListener('click', () => {
    settingsPanel.classList.add('show');
});

closeSettings.addEventListener('click', () => {
    settingsPanel.classList.remove('show');
});

// Update variables when settings change
document.getElementById('gravity').addEventListener('change', (e) => gravity = parseFloat(e.target.value));
document.getElementById('friction').addEventListener('change', (e) => friction = parseFloat(e.target.value));
document.getElementById('windowFriction').addEventListener('change', (e) => windowFriction = parseFloat(e.target.value));
document.getElementById('trampolineBounceFactor').addEventListener('change', (e) => trampolineBounceFactor = parseFloat(e.target.value));
document.getElementById('conveyorSpeed').addEventListener('change', (e) => conveyorSpeed = parseFloat(e.target.value));
document.getElementById('portalCooldown').addEventListener('change', (e) => portalCooldown = parseInt(e.target.value));
document.getElementById('fanForce').addEventListener('change', (e) => fanForce = parseFloat(e.target.value));
document.getElementById('fanRange').addEventListener('change', (e) => fanRange = parseFloat(e.target.value));
document.getElementById('fanLiftForce').addEventListener('change', (e) => fanLiftForce = parseFloat(e.target.value));
document.getElementById('fanHoverDistance').addEventListener('change', (e) => fanHoverDistance = parseFloat(e.target.value));
document.getElementById('buoyancyForce').addEventListener('change', (e) => buoyancyForce = parseFloat(e.target.value));
document.getElementById('waterDrag').addEventListener('change', (e) => waterDrag = parseFloat(e.target.value));
document.getElementById('resetSettings').addEventListener('click', () => {
    // Reset all variables to default values
    gravity = defaultSettings.gravity;
    friction = defaultSettings.friction;
    windowFriction = defaultSettings.windowFriction;
    trampolineBounceFactor = defaultSettings.trampolineBounceFactor;
    conveyorSpeed = defaultSettings.conveyorSpeed;
    portalCooldown = defaultSettings.portalCooldown;
    fanForce = defaultSettings.fanForce;
    fanRange = defaultSettings.fanRange;
    fanLiftForce = defaultSettings.fanLiftForce;
    fanHoverDistance = defaultSettings.fanHoverDistance;
    buoyancyForce = defaultSettings.buoyancyForce;
    waterDrag = defaultSettings.waterDrag;

    // Update all input fields to show default values
    document.getElementById('gravity').value = defaultSettings.gravity;
    document.getElementById('friction').value = defaultSettings.friction;
    document.getElementById('windowFriction').value = defaultSettings.windowFriction;
    document.getElementById('trampolineBounceFactor').value = defaultSettings.trampolineBounceFactor;
    document.getElementById('conveyorSpeed').value = defaultSettings.conveyorSpeed;
    document.getElementById('portalCooldown').value = defaultSettings.portalCooldown;
    document.getElementById('fanForce').value = defaultSettings.fanForce;
    document.getElementById('fanRange').value = defaultSettings.fanRange;
    document.getElementById('fanLiftForce').value = defaultSettings.fanLiftForce;
    document.getElementById('fanHoverDistance').value = defaultSettings.fanHoverDistance;
    document.getElementById('buoyancyForce').value = defaultSettings.buoyancyForce;
    document.getElementById('waterDrag').value = defaultSettings.waterDrag;
});
			
			function animate() {
			    windows.forEach((windowData, index) => {
			        if (windowData.window.closed) {
			            windows.splice(index, 1);
			            return;
			        }
			
			        updateWindowSize(windowData);
			
			        if (!windowData.isDragging) {
			            const oldX = windowData.x;
			            const oldY = windowData.y;
			
			            if (windowData.isFan && windowData.fanDirection === 'down') {
    const fanHoverHeight = window.screen.availHeight / 2;
    const distanceFromHoverHeight = Math.abs(windowData.y - fanHoverHeight);

    windowData.isFlying = true;
    const liftForce = fanLiftForce * (Math.min(distanceFromHoverHeight / fanHoverDistance, 1));
    
    if (windowData.y < fanHoverHeight) {
        windowData.vy += liftForce;
    } else {
        windowData.vy -= liftForce;
    }
    
    // Add damping to smooth out oscillations
    windowData.vy *= 0.95;
} else {
    windowData.isFlying = false;
    windowData.vy += gravity;
}
			
			            if (!windowData.isWater) {
			                applyWaterPhysics(windowData);
			            }
			
			            windowData.x += windowData.vx;
			            windowData.y += windowData.vy;
			
			            windowData.vx *= 0.98;
			
			            if (windowData.x < 0 || windowData.x + windowData.width > window.screen.availWidth) {
			                windowData.vx *= -0.8;
			                windowData.x = Math.max(0, Math.min(windowData.x, window.screen.availWidth - windowData.width));
			            }
			
			            if (windowData.y < 0) {
			                windowData.y = 0;
			                windowData.vy *= -0.8;
			            }
			
			            if (windowData.y + windowData.height > window.screen.availHeight) {
			                windowData.y = window.screen.availHeight - windowData.height;
			                windowData.vy *= -friction;
			                
			                if (Math.abs(windowData.vy) < 0.5) {
			                    windowData.vy = 0;
			                }
			            }
			
			            for (let i = 0; i < windows.length; i++) {
			                if (i !== index) {
			                    const otherWindow = windows[i];
			                    if (checkCollision(windowData, otherWindow)) {
			                        resolveCollision(windowData, otherWindow);
			                    }
			
			                    // Apply fan force
			                    if (windowData.isFan && !otherWindow.isFan) {
			                        applyFanForce(windowData, otherWindow);
			                    }
			
			                    // Check if a block is on top of a flying fan
			                    if (windowData.isFan && windowData.isFlying &&
			                        otherWindow.x < windowData.x + windowData.width &&
			                        otherWindow.x + otherWindow.width > windowData.x &&
			                        Math.abs(otherWindow.y + otherWindow.height - windowData.y) < 5) {
			                        otherWindow.y = windowData.y - otherWindow.height;
			                        otherWindow.vy = windowData.vy;
			                    }
			                }
			            }
			
			            windowData.window.moveTo(Math.round(windowData.x), Math.round(windowData.y));
			        }
			
			        if (windowData.lastFocusTime > 100) {
			            windowData.window.focus();
			            windowData.lastFocusTime = Date.now();
			        }
			    });
			
			    updatePortalCooldown();
			    requestAnimationFrame(animate);
			}
			
			document.getElementById('createWindow').addEventListener('click', () => createWindow(false));
			document.getElementById('createTrampoline').addEventListener('click', () => createWindow(true));
			document.getElementById('createConveyorBelt').addEventListener('click', () => createWindow(false, true));
			document.getElementById('createPortals').addEventListener('click', createPortals);
			document.getElementById('createFan').addEventListener('click', () => createWindow(false, false, false, true));
			document.getElementById('createEraser').addEventListener('click', () => createWindow(false, false, false, false, true));
			document.getElementById('createWater').addEventListener('click', () => createWindow(false, false, false, false, false, true));
			
			animate();
		</script>
	</body>
</html>
