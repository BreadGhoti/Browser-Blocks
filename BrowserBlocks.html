<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Blocks</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        button {
            font-size: 18px;
            padding: 10px 20px;
            margin: 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <button id="createWindow">Spawn Block</button>
    <button id="createTrampoline">Spawn Trampoline</button>

    <script>
        const gravity = 0.5;
        const friction = 0.3;
        const windowFriction = 0.95;
        const trampolineBounceFactor = 0.9;
        const windows = [];

        function createWindow(isTrampoline = false) {
            const width = Math.floor(Math.random() * 100) + 150;
            const height = Math.floor(Math.random() * 100) + 100;
            const color = isTrampoline ? '#000000' : `hsl(${Math.random() * 360}, 70%, 50%)`;
            const newWindow = window.open('', '', `width=${width},height=${height},resizable=yes`);
            
            newWindow.document.write(`
                <html>
                <head>
                    <title>${isTrampoline ? 'Trampoline' : 'Normal'} Block</title>
                    <style>
                        body {
                            background-color: ${color};
                            display: flex;
                            justify-content: center;
                            align-items: center;
                            height: 100vh;
                            margin: 0;
                            font-family: Arial, sans-serif;
                            color: ${isTrampoline ? 'white' : 'black'};
                            font-size: 18px;
                            user-select: none;
                            cursor: grab;
                        }
                        body:active {
                            cursor: grabbing;
                        }
                    </style>
                </head>
                <body>
                    <div>${isTrampoline ? 'Boing!' : 'Block'}</div>
                </body>
                </html>
            `);

            const windowData = {
                window: newWindow,
                width: width,
                height: height,
                x: Math.round(Math.random() * (window.screen.availWidth - width)),
                y: Math.round(Math.random() * (window.screen.availHeight - height)),
                vx: 0,
                vy: 0,
                isDragging: false,
                lastX: 0,
                lastY: 0,
                offsetX: 0,
                offsetY: 0,
                mass: width * height / 10000,
                lastFocusTime: Date.now(),
                isTrampoline: isTrampoline
            };

            newWindow.moveTo(windowData.x, windowData.y);
            newWindow.focus();

            newWindow.document.body.addEventListener('mousedown', (e) => {
                windowData.isDragging = true;
                windowData.offsetX = e.screenX - windowData.x;
                windowData.offsetY = e.screenY - windowData.y;
                windowData.lastX = e.screenX;
                windowData.lastY = e.screenY;
                windowData.vx = 0;
                windowData.vy = 0;
                windowData.lastFocusTime = Date.now();
            });

            newWindow.document.addEventListener('mousemove', (e) => {
                if (windowData.isDragging) {
                    windowData.x = e.screenX - windowData.offsetX;
                    windowData.y = e.screenY - windowData.offsetY;
                    newWindow.moveTo(windowData.x, windowData.y);

                    windowData.vx = e.screenX - windowData.lastX;
                    windowData.vy = e.screenY - windowData.lastY;
                    windowData.lastX = e.screenX;
                    windowData.lastY = e.screenY;
                }
            });

            newWindow.document.addEventListener('mouseup', () => {
                windowData.isDragging = false;
                windowData.vx *= 5;
                windowData.vy *= 5;
            });

            newWindow.addEventListener('blur', () => {
                windowData.isDragging = false;
            });

            newWindow.addEventListener('resize', () => {
                updateWindowSize(windowData);
            });

            windows.push(windowData);
        }

        function updateWindowSize(windowData) {
            const newWidth = windowData.window.outerWidth;
            const newHeight = windowData.window.outerHeight;
            const dx = newWidth - windowData.width;
            const dy = newHeight - windowData.height;

            // Update position to keep the window centered
            windowData.x -= dx / 2;
            windowData.y -= dy / 2;

            // Update dimensions and mass
            windowData.width = newWidth;
            windowData.height = newHeight;
            windowData.mass = windowData.width * windowData.height / 10000;

            // Ensure the window stays within screen bounds
            windowData.x = Math.max(0, Math.min(windowData.x, window.screen.availWidth - windowData.width));
            windowData.y = Math.max(0, Math.min(windowData.y, window.screen.availHeight - windowData.height));

            windowData.window.moveTo(Math.round(windowData.x), Math.round(windowData.y));
        }

        function checkCollision(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

        function resolveCollision(a, b) {
            if (a.isTrampoline || b.isTrampoline) {
                const trampolineWindow = a.isTrampoline ? a : b;
                const bouncingWindow = a.isTrampoline ? b : a;

                // Check if the bouncing window is above the trampoline
                if (bouncingWindow.y + bouncingWindow.height > trampolineWindow.y &&
                    bouncingWindow.y < trampolineWindow.y) {
                    // Bounce the window upwards
                    bouncingWindow.vy = -Math.abs(bouncingWindow.vy) * trampolineBounceFactor;
                    bouncingWindow.y = trampolineWindow.y - bouncingWindow.height;
                }
            } else {
                // Regular collision between non-trampoline windows
                const overlapX = Math.min(a.x + a.width, b.x + b.width) - Math.max(a.x, b.x);
                const overlapY = Math.min(a.y + a.height, b.y + b.height) - Math.max(a.y, b.y);

                if (overlapX < overlapY) {
                    // Horizontal collision
                    const tempVx = a.vx;
                    a.vx = b.vx;
                    b.vx = tempVx;
                    if (a.x < b.x) {
                        a.x = b.x - a.width;
                    } else {
                        a.x = b.x + b.width;
                    }
                } else {
                    // Vertical collision
                    const tempVy = a.vy;
                    a.vy = b.vy;
                    b.vy = tempVy;
                    if (a.y < b.y) {
                        a.y = b.y - a.height;
                    } else {
                        a.y = b.y + b.height;
                    }
                }

                const restitution = 0.8;
                a.vx *= restitution * windowFriction;
                a.vy *= restitution * windowFriction;
                b.vx *= restitution * windowFriction;
                b.vy *= restitution * windowFriction;
            }
        }

        function animate() {
            windows.forEach((windowData, index) => {
                if (windowData.window.closed) {
                    windows.splice(index, 1);
                    return;
                }

                updateWindowSize(windowData);

                if (!windowData.isDragging) {
                    const oldX = windowData.x;
                    const oldY = windowData.y;

                    windowData.vy += gravity;
                    windowData.x += windowData.vx;
                    windowData.y += windowData.vy;

                    windowData.vx *= 0.98;

                    if (windowData.x < 0 || windowData.x + windowData.width > window.screen.availWidth) {
                        windowData.vx *= -0.8;
                        windowData.x = Math.max(0, Math.min(windowData.x, window.screen.availWidth - windowData.width));
                    }

                    if (windowData.y < 0) {
                        windowData.y = 0;
                        windowData.vy *= -0.8;
                    }

                    if (windowData.y + windowData.height > window.screen.availHeight) {
                        windowData.y = window.screen.availHeight - windowData.height;
                        windowData.vy *= -friction;
                        
                        if (Math.abs(windowData.vy) < 0.5) {
                            windowData.vy = 0;
                        }
                    }

                    for (let i = 0; i < windows.length; i++) {
                        if (i !== index) {
                            const otherWindow = windows[i];
                            if (checkCollision(windowData, otherWindow)) {
                                resolveCollision(windowData, otherWindow);
                            }
                        }
                    }

                    windowData.window.moveTo(Math.round(windowData.x), Math.round(windowData.y));
                }

                // Focus management
                if (Date.now() - windowData.lastFocusTime > 100) {
                    windowData.window.focus();
                    windowData.lastFocusTime = Date.now();
                }
            });

            requestAnimationFrame(animate);
        }

        document.getElementById('createWindow').addEventListener('click', () => createWindow(false));
        document.getElementById('createTrampoline').addEventListener('click', () => createWindow(true));

        animate();
    </script>
</body>
</html>
